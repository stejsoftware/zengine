
    // MUL a b <result>
    private void zop_mul(ZCPU p)
    {
        int sop1, sop2;

        sop1 = signedWord(p.op1);

        sop2 = signedWord(p.op2);

        putVariable(p,p.curResult,unsignedWord(sop1 * sop2));
    }

    // DIV a b <result>
    private void zop_div(ZCPU p)
    {
        int sop1, sop2;

        if (p.op2 == 0)
            zui.fatal("Divide by zero");

        sop1 = signedWord(p.op1);

        sop2 = signedWord(p.op2);

        putVariable(p,p.curResult,unsignedWord(sop1 / sop2));
    }

    // MOD a b <result>
    private void zop_mod(ZCPU p)
    {
        int sop1, sop2;

        if (p.op2 == 0) {
            putVariable(p,p.curResult,p.op1);
            return;
        }

        sop1 = signedWord(p.op1);

        sop2 = signedWord(p.op2);

        putVariable(p,p.curResult,unsignedWord(sop1 % sop2));
    }

    // CALL_F1 raddr a1 <result>    V4+
    private void zop_call_f1(ZCPU p)
    {
		p.numvops = 2;
		p.vops[0] = p.op1;
		p.vops[1] = p.op2;
		zop_call_fv(p);
    }

    // CALL_P1 raddr a1     V5+
    private void zop_call_p1(ZCPU p)
    {
		p.numvops = 2;
		p.vops[0] = p.op1;
		p.vops[1] = p.op2;
		zop_call_pv(p);
    }

    // SET_COLOUR f b       V5+
    private void zop_set_colour(ZCPU p)
    {
		if (p.op1 == 1)
			p.op1 = p.memory.fetchByte(0x2d);
		if (p.op2 == 1)
			p.op2 = p.memory.fetchByte(0x2c);
		zui.setColor(p.op1,p.op2);
    }

    // THROW a fp       V5+
    private void zop_throw(ZCPU p)
    {
		// Pop the stack until we either find the frame being referenced, or the
		// stack underflows (a fatal error).
		while ((p.curCallFrame.frameNumber != p.op2) && (!p.callStack.empty()))
			p.curCallFrame = p.callStack.pop();
		if (p.curCallFrame.frameNumber != p.op2) // Stack underflow
			zui.fatal("THROW: Call stack underflow");

		// We have the frame; now do a RET a
		zop_ret(p);
    }


    ///////////////////////////////////////////////////////////////////
    // VARs
    ///////////////////////////////////////////////////////////////////

    // CALL_FV raddr [a1 a2 a3] <result>
	// CALL_FD raddr [a1 a2 a3 a4 a5 a6 a7] <result> V4+
    private void zop_call_fv(ZCPU p)
    {
        int addr;
        int numvars;
        int numargs;
		int newFrameNumber;

        // First, make sure raddr is not 0
        if (p.vops[0] == 0) {
            putVariable(p,p.curResult,0);
            return;
        }

		// Get the number of arguments
        numargs = p.numvops - 1;

        // Unpack the routine address
        addr = unpackAddr(p,p.vops[0],true);

//		System.out.println(Integer.toHexString(p.curCallFrame.pc) + " CALL " + Integer.toHexString(addr) + " " + vops[1] + " " + vops[2] + " " + vops[3] + " " + vops[4] + " " + vops[5] + " " + vops[6] + " " + vops[7] + "(" + numvops + ")" + " " + Integer.toHexString(getVariable(3)) + " " + Integer.toHexString(getVariable(5)));
        // Get the number of local variables
        numvars = p.memory.fetchByte(addr);

        // Bump the address past the variables byte, in any version
        addr++;

        // Back up the PC to point to the result byte
        p.curCallFrame.pc--;

		// Get the number of the next call frame.
		newFrameNumber = p.curCallFrame.frameNumber + 1;

        // Push the current call frame onto the stack.
		p.callStack.push(p.curCallFrame);

        // Initialize a new call frame
        p.curCallFrame = new ZCallFrame();

        // Put the PC at the appropriate place, depending on
        // whether local variables are present.
        if (p.version < 5)
            p.curCallFrame.pc = addr + (numvars * 2);
        else
            p.curCallFrame.pc = addr;

        // Create an empty routine stack
        p.curCallFrame.routineStack = new Stack<Integer>();

        // Initialize local variables
        p.curCallFrame.numLocalVars = numvars;
        for (int i = 0;i < numvars;i++) {
            // Fill in an argument in this variable, if one exists.
            if (i < numargs) {
                p.curCallFrame.localVars[i] = p.vops[i + 1];
                continue;
            }

            // Otherwise, if this is a pre-V5 game, fill in
            // a local variable.
            if (p.version < 5) {
                p.curCallFrame.localVars[i] = p.memory.fetchWord(addr + (i * 2));
                continue;
            }

            // Otherwise, just make this variable 0.
            p.curCallFrame.localVars[i] = 0;
        }

        // Store the call type (only strictly necessary in V3+)
        p.curCallFrame.callType = ZCallFrame.FUNCTION;

        // Store the number of arguments (only strictly necessary
        // in V5+)
        if (numargs > numvars)
            p.curCallFrame.argCount = numvars;
        else
            p.curCallFrame.argCount = numargs;

		// Stor the call frame number
		p.curCallFrame.frameNumber = newFrameNumber;
    }

    // STOREW baddr n a
    private void zop_storew(ZCPU p)
    {
        p.memory.putWord((p.vops[0] + (2 * p.vops[1])),p.vops[2]);
    }

    // STOREB baddr n byte
    private void zop_storeb(ZCPU p)
    {
        p.memory.putByte((p.vops[0] + p.vops[1]),p.vops[2]);
    }

    // PUT_PROP obj prop a
    private void zop_put_prop(ZCPU p)
    {
        p.objTable.putProperty(p.vops[0],p.vops[1],p.vops[2]);
    }

    // READ baddr1 baddr2                       V1-3
    // READ baddr1 baddr2 [time raddr]          V4
    // READ baddr1 baddr2 [time raddr] <result> V5+
    private void zop_read(ZCPU p)
    {
     //   DebugConsole.log("zop_read: " + run_state);
        
        String s;
        StringBuffer sb;
        int termChar;
        int len;
        int curaddr;
		int baddr1, baddr2;
        int time = 0, raddr = 0;
        
		baddr1 = p.vops[0];
		baddr2 = p.vops[1];
        if (p.numvops > 2) {
            time = p.vops[2];
            raddr = p.vops[3];
        }
        
		// Flush the I/O card's output buffer
        p.ioCard.outputFlush();

        // This implies a SHOW_STATUS in V1-3.
        if (p.version < 4)
            zop_show_status(p);

        // Read a line of text
        sb = new StringBuffer();
        if ((time > 0) && (raddr > 0)) { // A timed READ
            while (true) { // Ick.
                termChar = p.ioCard.readLine(sb,time);
                if (termChar == -1) { // A timeout
//                    ioCard.outputFlush(p);
//                    did_newline = false;
                    for (int i = 0; i < sb.length(); i++)
                        p.ioCard.printString("\b");
                    int rc = interrupt(p,raddr);
                    if (rc == 0) {
//                        if (did_newline) {
//                            ioCard.printString("\n" + sb.toString(p));
//                            ioCard.outputFlush(p);
//                        }
                        p.ioCard.printString(sb.toString());
                        p.ioCard.outputFlush();
                        continue;
                    }
                    else {
                        p.ioCard.outputFlush();
                        sb = new StringBuffer();
                        termChar = 0;
                        break;
                    }
                }
                else // Not a timeout
                    break;
            }
        }
        else
        {
            termChar = p.ioCard.readLine(sb, 0);

            if( termChar == -1 )
            {
                p.pause();
                return;
            }
        }
        
        s = sb.toString();
        
        // If V1-4, just store the line.  If V5+, possibly
        // store it after other characters in the buffer.
        if (p.version <= 4) {
            curaddr = baddr1 + 1;
            len = s.length();
            for (int i = 0;i < len;i++) {
                p.memory.putByte(curaddr,Character.toLowerCase(s.charAt(i)));
                curaddr++;
            }
            p.memory.putByte(curaddr,0);
        }
        else {
            int nchars = p.memory.fetchByte(baddr1 + 1);
			curaddr = baddr1 + 2 + nchars;
			len = s.length();
			for (int i = 0;i < len;i++) {
				p.memory.putByte(curaddr,Character.toLowerCase(s.charAt(i)));
				curaddr++;
			}
			p.memory.putByte(baddr1+1,(nchars + len));
        }

		// Tokenize input
		if (baddr2 != 0) {
			p.vops[0] = baddr1;
			p.vops[1] = baddr2;
			p.numvops = 2;
			zop_tokenise(p);
		}

        // If V5+, store result
		if (p.version >= 5)
			putVariable(p,p.curResult,termChar);
    }

    // PRINT_CHAR n
    private void zop_print_char(ZCPU p)
    {
        String s;

        s = new String(String.valueOf((char)p.vops[0]));
        p.ioCard.printString(s);
    }

    // PRINT_NUM s
    private void zop_print_num(ZCPU p)
    {
        int sop1;
        String s;

        sop1 = signedWord(p.vops[0]);

        s = new String(String.valueOf(sop1));
        p.ioCard.printString(s);
    }

    // RANDOM s <result>
    private void zop_random(ZCPU p)
    {
        if (signedWord(p.vops[0]) > 0)
            putVariable(p,p.curResult,p.rndgen.getRandom(signedWord(p.vops[0])));
        else {
            p.rndgen.seed(signedWord(p.vops[0]));
            putVariable(p,p.curResult,0);
        }
    }

    // PUSH a
    private void zop_push(ZCPU p)
    {
        putVariable(p,0,p.vops[0]);
    }

    // PULL var                 V1-5,7-8
    // PULL [baddr] <result>    V6
    private void zop_pull(ZCPU p)
    {
        // This will need to be extended for V6 support
        putVariable(p,p.vops[0],getVariable(p,0));
    }

    // SPLIT_SCREEN n           V3+
    private void zop_split_screen(ZCPU p)
    {
        p.ioCard.outputFlush();
        zui.splitScreen(p.vops[0]);
    }

    // SET_WINDOW window        V3+
    private void zop_set_window(ZCPU p)
    {
        p.ioCard.outputFlush();

        // In V6, -3 represents the current window
        zui.setCurrentWindow(p.vops[0]);
    }

    // CALL_FD raddr [a1 a2 a3 a4 a5 a6 a7] <result>    V4+
    private void zop_call_fd(ZCPU p)
    {
		// CALL_FV actually handles this
		zop_call_fv(p);
    }

    // ERASE_WINDOW window      V4+
    private void zop_erase_window(ZCPU p)
    {
		int sop1;

		sop1 = signedWord(p.vops[0]);
		if (sop1 == -1) { // Erase everything, do a SPLIT_SCREEN 0
			zui.eraseWindow(0);
			zui.eraseWindow(1);
			p.vops[0] = 0;
			p.numvops = 1;
			zop_split_screen(p);
			return;
		}
		else // In V6, we'll have to handle -2 explicitly
			zui.eraseWindow(p.vops[0]);
    }

    // ERASE_LINE               V4-5,7-8
    // ERASE_LINE n             V6
    private void zop_erase_line(ZCPU p)
    {
		zui.eraseLine(1);
    }

    // SET_CURSOR s x           V4-5,7-8
    // SET_CURSOR s x [window]  V6
    private void zop_set_cursor(ZCPU p)
    {
		p.ioCard.outputFlush();
		zui.setCursorPosition(p.vops[1],p.vops[0]);
    }

    // GET_CURSOR baddr         V4+
    private void zop_get_cursor(ZCPU p)
    {
		Point pt;

		p.ioCard.outputFlush();
		pt = zui.getCursorPosition();
		p.memory.putWord(p.vops[0],pt.y);
		p.memory.putWord(p.vops[0]+2,pt.x);
    }

    // SET_TEXT_STYLE n         V4+
    private void zop_set_text_style(ZCPU p)
    {
        p.ioCard.outputFlush();
        zui.setTextStyle(p.vops[0]);
		Dimension s = zui.getFontSize();
		p.memory.putByte(0x26,s.height);
		p.memory.putByte(0x27,s.width);
    }

    // BUFFER_MODE bit          V4+
    private void zop_buffer_mode(ZCPU p)
    {
		// This doesn't really fit in with our buffering method, so we ignore it.
		// Flush the buffer, though.
		p.ioCard.outputFlush();
    }

    // OUTPUT_STREAM s              V3-4
    // OUTPUT_STREAM s [baddr]      V5,7-8
    // OUTPUT_STREAM s [baddr w]    V6
    private void zop_output_stream(ZCPU p)
    {
       // int w;

        if (p.numvops == 3)
            p.ioCard.setOutputStream(signedWord(p.vops[0]),p.vops[1],p.vops[2],true);
        else
            p.ioCard.setOutputStream(signedWord(p.vops[0]),p.vops[1],0,false);
    }

    // INPUT_STREAM n               V3+
    private void zop_input_stream(ZCPU p)
    {
        p.ioCard.setInputStream(p.vops[0]);
    }

    // SOUND n [op time raddr]      V3+
    private void zop_sound(ZCPU p)
    {
        // Silently fail on this instruction if no raddr argument;
        // otherwise, go straight to raddr for now.
        if (p.numvops == 1)
            return;

        if (p.vops[1] != 2)
            return;

        // Pretend a CALL_P0 has just been executed.
        p.op1 = p.vops[3];
        p.op1type = p.voptypes[3];
        zop_call_p0(p);
    }

    // READ_CHAR 1 [time raddr] <result>    V4+
    private void zop_read_char(ZCPU p)
    {
		int c;

		p.ioCard.outputFlush();
		if ((p.numvops > 1) && (p.vops[1] != 0) && (p.vops[2] != 0)) { // A timed READ_CHAR
		    while (true) { // Yuck.
		        c = p.ioCard.readChar(p.vops[1]);
		        if (c == -1) { // A timeout
		            int rc = interrupt(p,p.vops[2]);
		            if (rc == 0)
		                continue;
		            else {
		                putVariable(p,p.curResult,0);
		                return;
		            }
		        }
		        else { // A character
		            putVariable(p,p.curResult,c);
		            return;
		        }
		    }
		}
		else {
    		c = p.ioCard.readChar(0);
	    	putVariable(p,p.curResult,c);
	    }
    }

    // SCAN_TABLE a baddr n [byte] <result> <branch>    V4+
    private void zop_scan_table(ZCPU p)
    {
        int a, baddr, n, format;
        boolean searchWord; // Searching for a word (not a byte)?
        int tableWidth; // Width of table
        int testAddr; // Address to test
        int testData; // Data to test

        // Get operands
        a = p.vops[0];
        baddr = p.vops[1];
        n = p.vops[2];
        if (p.numvops == 4)
            format = p.vops[3];
        else
            format = 0x82;
        if ((format & 0x80) == 0x80)
            searchWord = true;
        else
            searchWord = false;
        tableWidth = (format & 0x7f);

        // Fail if it's a table of bytes and a is word-valued
        if ((tableWidth == 2) && (p.voptypes[0] == ARGTYPE_BYTE)) {
            putVariable(p,p.curResult,0);
            dontBranch(p);
            return;
        }

        // Search the table
        for (int i=0;i<n;i++) {
            testAddr = (baddr + (i * tableWidth));
            if (searchWord)
                testData = p.memory.fetchWord(testAddr);
            else
                testData = p.memory.fetchByte(testAddr);
            if (testData == a) { // A match!
                putVariable(p,p.curResult,(baddr + (i * tableWidth)));
                doBranch(p);
                return;
            }
        }

        // If we get here, there was no match, or n < 1
        putVariable(p,p.curResult,0);
        dontBranch(p);
        return;
    }

    // CALL_PV raddr [a1 a2 a3]     V5+
    // CALL_PD raddr [a1 a2 a3 a4 a5 a6 a7]     V5+
    private void zop_call_pv(ZCPU p)
    {
        int addr;
        int numvars;
        int numargs;
		int newFrameNumber;

        // First, make sure raddr is not 0
        if (p.vops[0] == 0) {
            putVariable(p,p.curResult,0);
            return;
        }

		// Get the number of arguments
        numargs = p.numvops - 1;

        // Unpack the routine address
        addr = unpackAddr(p,p.vops[0],true);

		// System.out.println(Integer.toHexString(p.curCallFrame.pc) + " CALL " + Integer.toHexString(addr) + " " + p.vops[1] + " " + p.vops[2] + " " + p.vops[3]);

        // Get the number of local variables
        numvars = p.memory.fetchByte(addr);

        // Bump the address past the variables byte, in any version
        addr++;

		// Get the number of the next call frame.
		newFrameNumber = p.curCallFrame.frameNumber + 1;

        // Push the current call frame onto the stack.
		p.callStack.push(p.curCallFrame);

        // Initialize a new call frame
        p.curCallFrame = new ZCallFrame();

        // Put the PC at the appropriate place, depending on
        // whether local variables are present.
        if (p.version < 5)
            p.curCallFrame.pc = addr + (numvars * 2);
        else
            p.curCallFrame.pc = addr;

        // Create an empty routine stack
        p.curCallFrame.routineStack = new Stack<Integer>();

        // Initialize local variables
        p.curCallFrame.numLocalVars = numvars;
        for (int i = 0;i < numvars;i++) {
            // Fill in an argument in this variable, if one exists.
            if (i < numargs) {
                p.curCallFrame.localVars[i] = p.vops[i + 1];
                continue;
            }

            // Otherwise, if this is a pre-V5 game, fill in
            // a local variable.
            if (p.version < 5) {
                p.curCallFrame.localVars[i] = p.memory.fetchWord(addr + (i * 2));
                continue;
            }

            // Otherwise, just make this variable 0.
            p.curCallFrame.localVars[i] = 0;
        }

        // Store the call type (only strictly necessary in V3+)
        p.curCallFrame.callType = ZCallFrame.PROCEDURE;

        // Store the number of arguments (only strictly necessary
        // in V5+)
        if (numargs > numvars)
            p.curCallFrame.argCount = numvars;
        else
            p.curCallFrame.argCount = numargs;

		// Store the call frame number
		p.curCallFrame.frameNumber = newFrameNumber;
    }

